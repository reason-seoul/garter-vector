// Generated by ReScript, PLEASE EDIT WITH CARE

import * as JsArray from "./JsArray.js";
import * as Caml_obj from "@rescript/std/lib/es6/caml_obj.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";

function findIndex(param, key) {
  return param.entries.findIndex(function (param) {
              return Caml_obj.caml_equal(param[0], key);
            });
}

function assoc(self, key, value) {
  var idx = findIndex(self, key);
  if (idx === -1) {
    return {
            hash: self.hash,
            entries: JsArray.cloneAndAdd(self.entries, [
                  key,
                  value
                ])
          };
  } else {
    return self;
  }
}

function dissoc(self, key) {
  var entries = self.entries;
  var idx = findIndex(self, key);
  if (idx === -1) {
    return self;
  } else if (entries.length === 1) {
    return ;
  } else {
    return {
            hash: self.hash,
            entries: JsArray.cloneWithout(entries, idx)
          };
  }
}

function mask(hash, shift) {
  return (hash >>> shift) & 31;
}

function bitpos(hash, shift) {
  return (1 << mask(hash, shift));
}

function indexOfBit(bitmap, bit) {
  var v = bitmap & (bit - 1 | 0);
  var v$1 = v - ((v >>> 1) & 1431655765) | 0;
  var v$2 = (v$1 & 858993459) + ((v$1 >>> 2) & 858993459) | 0;
  var v$3 = v$2 + (v$2 >>> 4) & 252645135;
  var v$4 = v$3 + (v$3 >>> 8) | 0;
  var v$5 = v$4 + (v$4 >>> 16) | 0;
  return v$5 & 127;
}

function assocBitmapIndexed(self, shift, hasher, hash, key, value) {
  var data = self.data;
  var bitmap = self.bitmap;
  var bit = bitpos(hash, shift);
  var idx = indexOfBit(bitmap, bit);
  var match = bitmap & bit;
  if (match === 0) {
    return {
            bitmap: bitmap | bit,
            data: JsArray.cloneAndInsert(data, idx, {
                  TAG: /* MapEntry */1,
                  _0: [
                    key,
                    value
                  ]
                })
          };
  }
  var child = data[idx];
  switch (child.TAG | 0) {
    case /* BitmapIndexed */0 :
        var trie = child._0;
        var newChild = assocBitmapIndexed(trie, shift + 5 | 0, hasher, hash, key, value);
        if (newChild === trie) {
          return self;
        } else {
          return {
                  bitmap: bitmap,
                  data: JsArray.cloneAndSet(data, idx, {
                        TAG: /* BitmapIndexed */0,
                        _0: newChild
                      })
                };
        }
    case /* MapEntry */1 :
        var match$1 = child._0;
        var v = match$1[1];
        var k = match$1[0];
        if (Caml_obj.caml_equal(k, key)) {
          if (Caml_obj.caml_equal(v, value)) {
            return self;
          } else {
            return {
                    bitmap: bitmap,
                    data: JsArray.cloneAndSet(data, idx, {
                          TAG: /* MapEntry */1,
                          _0: [
                            k,
                            v
                          ]
                        })
                  };
          }
        }
        var leaf = makeNode(shift + 5 | 0, hasher, hasher(k), k, v, hash, key, value);
        return {
                bitmap: bitmap,
                data: JsArray.cloneAndSet(data, idx, leaf)
              };
    case /* HashCollision */2 :
        var node = child._0;
        if (node.hash === hash) {
          var newChild$1 = assoc(node, key, value);
          if (newChild$1 === node) {
            return self;
          } else {
            return {
                    bitmap: bitmap,
                    data: JsArray.cloneAndSet(data, idx, {
                          TAG: /* HashCollision */2,
                          _0: newChild$1
                        })
                  };
          }
        }
        var newChild$2 = assocBitmapIndexed({
              bitmap: bitpos(node.hash, shift + 5 | 0),
              data: [{
                  TAG: /* HashCollision */2,
                  _0: node
                }]
            }, shift + 5 | 0, hasher, hash, key, value);
        return {
                bitmap: bitmap,
                data: JsArray.cloneAndSet(data, idx, {
                      TAG: /* BitmapIndexed */0,
                      _0: newChild$2
                    })
              };
    
  }
}

function makeNode(shift, hasher, h1, k1, v1, h2, k2, v2) {
  if (h1 === h2) {
    return {
            TAG: /* HashCollision */2,
            _0: {
              hash: h1,
              entries: [
                [
                  k1,
                  v1
                ],
                [
                  k2,
                  v2
                ]
              ]
            }
          };
  } else {
    return {
            TAG: /* BitmapIndexed */0,
            _0: assocBitmapIndexed(assocBitmapIndexed({
                      bitmap: 0,
                      data: []
                    }, shift, hasher, h1, k1, v1), shift, hasher, h2, k2, v2)
          };
  }
}

function dissocBitmapIndexed(self, shift, hash, key) {
  var data = self.data;
  var bitmap = self.bitmap;
  var bit = bitpos(hash, shift);
  var match = bitmap & bit;
  if (match === 0) {
    return self;
  }
  var idx = indexOfBit(bitmap, bit);
  var child = data[idx];
  switch (child.TAG | 0) {
    case /* BitmapIndexed */0 :
        var trie = child._0;
        var newChild = dissocBitmapIndexed(trie, shift + 5 | 0, hash, key);
        if (newChild !== undefined) {
          if (newChild === trie) {
            return self;
          } else {
            return {
                    bitmap: bitmap,
                    data: JsArray.cloneAndSet(data, idx, {
                          TAG: /* BitmapIndexed */0,
                          _0: newChild
                        })
                  };
          }
        } else {
          return unset(self, bit, idx);
        }
    case /* MapEntry */1 :
        if (Caml_obj.caml_equal(child._0[0], key)) {
          return unset(self, bit, idx);
        } else {
          return self;
        }
    case /* HashCollision */2 :
        var node = child._0;
        var newChild$1 = dissoc(node, key);
        if (newChild$1 !== undefined) {
          if (newChild$1 === node) {
            return self;
          } else {
            return {
                    bitmap: bitmap,
                    data: JsArray.cloneAndSet(data, idx, {
                          TAG: /* HashCollision */2,
                          _0: newChild$1
                        })
                  };
          }
        } else {
          return unset(self, bit, idx);
        }
    
  }
}

function unset(param, bit, idx) {
  var bitmap = param.bitmap;
  if (bitmap === bit) {
    return ;
  } else {
    return {
            bitmap: bitmap ^ bit,
            data: JsArray.cloneWithout(param.data, idx)
          };
  }
}

function empty(param) {
  return {
          TAG: /* BitmapIndexed */0,
          _0: {
            bitmap: 0,
            data: []
          }
        };
}

function find(node, shift, hash, key) {
  switch (node.TAG | 0) {
    case /* BitmapIndexed */0 :
        var _param = node._0;
        var _shift = shift;
        while(true) {
          var param = _param;
          var shift$1 = _shift;
          var bitmap = param.bitmap;
          var bit = bitpos(hash, shift$1);
          var match = bitmap & bit;
          if (match === 0) {
            return ;
          }
          var idx = indexOfBit(bitmap, bit);
          var child = param.data[idx];
          switch (child.TAG | 0) {
            case /* BitmapIndexed */0 :
                _shift = shift$1 + 5 | 0;
                _param = child._0;
                continue ;
            case /* MapEntry */1 :
                var match$1 = child._0;
                if (Caml_obj.caml_equal(match$1[0], key)) {
                  return Caml_option.some(match$1[1]);
                } else {
                  return ;
                }
            case /* HashCollision */2 :
                var param$1 = child._0;
                var match$2 = param$1.entries.find(function (param) {
                      return Caml_obj.caml_equal(param[0], key);
                    });
                if (match$2 !== undefined) {
                  return Caml_option.some(match$2[1]);
                } else {
                  return ;
                }
            
          }
        };
    case /* MapEntry */1 :
    case /* HashCollision */2 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Hamt.res",
                310,
                9
              ],
              Error: new Error()
            };
    
  }
}

function assoc$1(node, shift, hasher, hash, key, value) {
  switch (node.TAG | 0) {
    case /* BitmapIndexed */0 :
        var node$1 = node._0;
        var newNode = assocBitmapIndexed(node$1, shift, hasher, hash, key, value);
        if (newNode === node$1) {
          return ;
        } else {
          return {
                  TAG: /* BitmapIndexed */0,
                  _0: newNode
                };
        }
    case /* MapEntry */1 :
    case /* HashCollision */2 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Hamt.res",
                326,
                9
              ],
              Error: new Error()
            };
    
  }
}

function dissoc$1(node, shift, hash, key) {
  switch (node.TAG | 0) {
    case /* BitmapIndexed */0 :
        var node$1 = node._0;
        var newNode = dissocBitmapIndexed(node$1, shift, hash, key);
        if (newNode !== undefined) {
          if (newNode === node$1) {
            return ;
          } else {
            return {
                    TAG: /* BitmapIndexed */0,
                    _0: newNode
                  };
          }
        } else {
          return {
                  TAG: /* BitmapIndexed */0,
                  _0: {
                    bitmap: 0,
                    data: []
                  }
                };
        }
    case /* MapEntry */1 :
    case /* HashCollision */2 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Hamt.res",
                345,
                9
              ],
              Error: new Error()
            };
    
  }
}

export {
  empty ,
  find ,
  assoc$1 as assoc,
  dissoc$1 as dissoc,
  
}
/* No side effect */
