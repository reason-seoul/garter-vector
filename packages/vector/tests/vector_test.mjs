// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Zora from "@dusty-phillips/rescript-zora/src/Zora.mjs";
import * as Zora$1 from "zora";
import * as Vector from "../src/Vector.mjs";
import * as Js_math from "@rescript/std/lib/es6/js_math.js";
import * as Caml_obj from "@rescript/std/lib/es6/caml_obj.js";
import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";

function isomorphic(ar) {
  return Caml_obj.caml_equal(Vector.toArray(Vector.fromArray(ar)), ar);
}

function pushpop(n, m) {
  var v = Vector.fromArray(Belt_Array.range(1, n));
  return Belt_Array.reduce(Belt_Array.range(1, m), v, (function (v, param) {
                return Vector.pop(v);
              }));
}

Zora$1.test("Vector initialize", (function (t) {
        t.equal(Vector.length(Vector.make(undefined)), 0, "make empty vector");
        t.equal(Vector.fromArray([]), Vector.make(undefined), "make from empty array");
        Belt_Array.forEach(Belt_Array.range(1, 32), (function (n) {
                t.ok(isomorphic(Belt_Array.range(1, n)), "fromArray length=" + String(n));
                
              }));
        Belt_Array.forEach(Belt_Array.rangeBy(1000, 10000, 1000), (function (n) {
                t.ok(isomorphic(Belt_Array.range(1, n)), "fromArray length=" + String(n));
                
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.push", (function (t) {
        t.test("push", (function (t) {
                Belt_Array.forEach(Belt_Array.range(1, 64), (function (n) {
                        var v1 = Belt_Array.reduce(Belt_Array.range(1, n), Vector.make(undefined), Vector.push);
                        var v2 = Vector.fromArray(Belt_Array.range(1, n));
                        t.equal(v1, v2, "should be equal");
                        
                      }));
                return Zora.done(undefined);
              }));
        t.test("root overflow", (function (t) {
                var v1 = Belt_Array.reduce(Belt_Array.range(1, 32768), Vector.make(undefined), Vector.push);
                var v2 = Vector.fromArray(Belt_Array.range(1, 32768));
                t.equal(v1, v2, "should be equal");
                return Zora.done(undefined);
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.pop", (function (t) {
        t.test("pop", (function (t) {
                Belt_Array.forEach([
                      [
                        100,
                        50
                      ],
                      [
                        100,
                        100
                      ],
                      [
                        10000,
                        5000
                      ]
                    ], (function (param) {
                        var m = param[1];
                        var n = param[0];
                        t.equal(Vector.toArray(pushpop(n, m)), Belt_Array.range(1, n - m | 0), "should be equal");
                        
                      }));
                return Zora.done(undefined);
              }));
        t.test("root overflow", (function (t) {
                var ar = Belt_Array.range(1, 32768);
                var v = Vector.fromArray(ar);
                var ev = Belt_Array.reduce(ar, v, (function (v, param) {
                        return Vector.pop(v);
                      }));
                t.ok(Vector.length(ev) === 0, "should be empty");
                return Zora.done(undefined);
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.get", (function (t) {
        var v = pushpop(20000, 10000);
        t.test("random access (10,000 times)", (function (t) {
                var every = Belt_Array.every(Belt_Array.range(1, 10000), (function (param) {
                        var idx = Js_math.random_int(0, 10000);
                        return Vector.getExn(v, idx) === (idx + 1 | 0);
                      }));
                t.ok(every, "should be succeed");
                
              }));
        t.test("tail offset 0", (function (t) {
                var v = Vector.push(Vector.make(undefined), 1);
                var v$p = Vector.setUnsafe(v, 0, 2);
                t.is(Vector.getUnsafe(v$p, 0), 2, "should be 2");
                
              }));
        t.test("optional get", (function (t) {
                return Belt_Array.forEach([
                            -1,
                            0,
                            10000
                          ], (function (idx) {
                              var match = Vector.get(v, idx);
                              if (match !== undefined) {
                                t.ok(idx >= 0 && idx < Vector.length(v), "should be ok");
                              } else {
                                t.notOk(idx >= 0 && idx < Vector.length(v), "should not be ok");
                              }
                              
                            }));
              }));
        t.test("out of bounds", (function (t) {
                Zora.optionNone(t, Vector.get(v, -1), "should be none");
                return Zora.optionNone(t, Vector.get(v, 10000), "should be none");
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.set", (function (t) {
        var v = Vector.fromArray(Belt_Array.range(1, 10000));
        t.test("random update (" + 10000 + " items)", (function (t) {
                var ar = Belt_Array.shuffle(Belt_Array.range(1, 10000));
                var v$p = Belt_Array.reduce(ar, v, (function (v, idx) {
                        return Vector.setExn(v, idx - 1 | 0, Math.imul(idx, -1));
                      }));
                var every = Belt_Array.every(Vector.toArray(v$p), (function (x) {
                        return x < 0;
                      }));
                t.ok(every, "shoud be ok");
                
              }));
        t.test("optional set", (function (t) {
                return Belt_Array.forEach([
                            -1,
                            0,
                            10000
                          ], (function (idx) {
                              var match = Vector.set(v, idx, 42);
                              if (match !== undefined) {
                                t.ok(idx >= 0 && idx < Vector.length(v), "should be ok");
                              } else {
                                t.notOk(idx >= 0 && idx < Vector.length(v), "should not be ok");
                              }
                              
                            }));
              }));
        var ar = Belt_Array.range(1, 10000);
        t.test("mutable random update (" + 10000 + " times)", (function (t) {
                Belt_Array.forEach(Belt_Array.shuffle(Belt_Array.range(1, 10000)), (function (idx) {
                        ar[idx - 1 | 0] = Math.imul(idx, -1);
                        
                      }));
                var every = Belt_Array.every(ar, (function (x) {
                        return x < 0;
                      }));
                t.ok(every, "should be ok");
                
              }));
        return Zora.done(undefined);
      }));

Zora$1.test("Vector.reduce", (function (t) {
        var v = Vector.fromArray(Belt_Array.range(1, 100));
        t.test("sum", (function (t) {
                var sum = Vector.reduce(v, 0, (function (acc, i) {
                        return acc + i | 0;
                      }));
                t.is(sum, 5050, "sum is 5050");
                
              }));
        t.test("sum (uncurried)", (function (t) {
                var sum = Vector.reduceU(v, 0, (function (acc, i) {
                        return acc + i | 0;
                      }));
                t.is(sum, 5050, "sum is 5050");
                
              }));
        return Zora.done(undefined);
      }));

var A;

var V;

export {
  A ,
  V ,
  isomorphic ,
  pushpop ,
  
}
/*  Not a pure module */
